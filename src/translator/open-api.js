// ***************************************************
// to OpenAPI document
// passes https://apitools.dev/swagger-parser/online/
// ***************************************************

const YAML = require('yamljs');

const { taxonomy, groups, safe, unsafe, update, remove, metadata_title, metadata_root } = require('../util/alps-predicates')
const utils = require('../util/print-utils.js');

const toOAS = (doc, options) => {

  // empty OAS document
  let oas = {
    openapi: '3.0.2',
  };

  info(oas, doc);

  servers(oas, doc);

  paths(oas, doc);

  components(oas, doc);    

  // print output
  const output = YAML.stringify(oas, 10, 2);
  
  // do not print header if options.omitHeader is true
  if (!options.omitHeader) {
     return header + output;
  }

  return output;
}
  
const header = 
`# *******************************************************************
# generated by "unified"
# date: ${new Date()}
#
# http://github.com/mamund/alps-unified
# *******************************************************************
`;

// set info
const info = (oas, doc) => {

  let info = {};

  // hack to get unified to build/run : remove ?.value from lines 53 & 54 : @mamund
  info.title = doc.title // from title
      || doc.ext.find(e => metadata_title(e) && e.value) //?.value  // from extensions
      || doc.doc.find(d => d.contentType === 'text/plain' && d.value && d.value.length <= 40) //?.value   // from doc
      || 'Generated OAS from ALPS'
      ;

  info.version = '0.0.1'  //TODO extract a version from ALPS
  
  info.description = doc.doc.filter(d => d.contentType === 'text/plain' && (!info.title || d.value !== info.title))
                            .map(d => d.value)
                            .join('\n'),

  // filter out undefined entries  
  oas.info = Object
              .entries(info)
              .filter(([, value]) => value)
              .reduce((p, [key, value]) => {  p[key] = value;  return p; }, {} );
}


// set servers
const servers = (oas, doc) => {

  const list = doc.link.filter(l => l.rel === 'server').map(l => { return { url: l.href }}) // from links
                  .concat(doc.ext.filter(e => metadata_root(e) && e.value).map(e => { return { url: e.value }}))   // from ext
                ;  

  // set info only if it's not empty'
  if (list.length > 0) {
    oas.servers = list;
  }  
}

// set paths
const paths = (oas, doc) => {
  
  let paths = {};
  
  // paths
  doc.descriptor
    .forEach(item => {
      
      let methods = {};
      
      // gets
      if (safe(item)) {  
        methods.get = {
          summary: item.text || item.id,
          operationId: item.id,
          responses: {
            '200': {
                description: item.id,
                content: {
                  'application/json': {
                    schema: {
                      type: 'array',
                      items: {
                        $ref: `#/components/schemas/${normalizeUrl(item.return)}`,
                      }
                    }
                  }
                }
            }
          }
        };
      }

      // posts
      if (unsafe(item)) {  
        methods.post = {
          summary: item.text || item.id,
          operationId: item.id,
          requestBody: {
            content: {
              'application/json': {
                schema: {
                  type: 'array',
                  items: {
                    $ref: `#/components/schemas/${normalizeUrl(item.return)}`,
                  }
                }
              }
            }            
          },
          responses: {
            '200': {
                description: 'add ' + item.id,
                content: {
                  'application/json': {
                    schema: {
                      type: 'array',
                      items: {
                        $ref: `#/components/schemas/${normalizeUrl(item.return)}`,
                      }
                    }
                  }
                }
            }
          }
        };
      }

      // puts
      if (update(item)) {  
        methods.put = {
          summary: item.text || item.id,
          operationId: item.id,
          requestBody: {
            content: {
              'application/json': {
                schema: {
                  type: 'array',
                  items: {
                    $ref: `#/components/schemas/${normalizeUrl(item.return)}`,
                  }
                }
              }
            }            
          },
          responses: {
            '200': {
                description: 'add ' + item.id,
                content: {
                  'application/json': {
                    schema: {
                      type: 'array',
                      items: {
                        $ref: `#/components/schemas/${normalizeUrl(item.return)}`,
                      }
                    }
                  }
                }
            }
          }
        };
      }
      
      // deletes
      if (remove(item)) {  
        methods.delete = {
          summary: item.text || item.id,
          operationId: item.id,
          parameters: item.descriptor.map(prop => {
            return {
              name: prop.href,
              in: 'path',
              description: `${prop.href} of ${item.id}`,
              required: true,
              schema: {
                type: 'string'
              }      
            };
          }),
          responses: {
            '204': {
                description: 'delete ' + item.id,
            }
          }
        };
      }

      // if methods are not empty
      if (Object.keys(methods).length > 0) {
        paths['/' + item.id] = methods;
      }
    });
    
    if (Object.keys(paths).length > 0) {
      oas.paths = paths;
    }
}

const components = (oas, doc) => {

  let schemas = {};
  
  doc.descriptor
    .filter(taxonomy)
    .forEach(item => {
      schemas[item.id] = {
        type: 'object',
        properties: {},
      };
      
      if (item.text) {
          schemas[item.id].description = item.text;
      }
      
      item.descriptor.forEach(prop => {
          schemas[item.id].properties[prop.href] = {
            type: 'string',
            example: utils.rString(prop.href), 
          }
      });
    });
  
  // if schemas are not empty
  if (Object.keys(schemas).length > 0) {
    oas.components = { schemas: schemas };
  }
}

const isFragment = url => url && url.startsWith('#');

const normalizeUrl = url => isFragment(url) ? url.substring(1) : url;

module.exports = toOAS;
